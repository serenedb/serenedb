////////////////////////////////////////////////////////////////////////////////
/// DISCLAIMER
///
/// Copyright 2025 SereneDB GmbH, Berlin, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is SereneDB GmbH, Berlin, Germany
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <string>
#include <type_traits>

#include "basics/bit_utils.hpp"
#include "basics/identifier.h"
#include "catalog/identifiers/identifier.h"
#include "vpack/builder.h"
#include "vpack/serializer.h"

namespace sdb::catalog {

enum class ObjectType : uint8_t {
  Invalid = 0,
  Function,
  Index,
  Table,
  View,
  Role,
  Schema,
  Database,
  Virtual,
};

// https://www.postgresql.org/docs/current/sql-grant.html
enum class AclMode : uint64_t {
  NoRights = 0U,
  Insert = 1U << 0,
  Select = 1U << 1,
  Update = 1U << 2,
  Delete = 1U << 3,
  Truncate = 1U << 4,
  References = 1U << 5,
  Trigger = 1U << 6,
  Execute = 1U << 7,
  Usage = 1U << 8,
  Create = 1U << 9,
  CreateTemp = 1U << 10,
  Connect = 1U << 11,
  Set = 1U << 12,
  AlterSystem = 1U << 13,
};

ENABLE_BITMASK_ENUM(AclMode);

struct AclItem {
  ObjectId grantee = id::kInvalid;
  ObjectId grantor = id::kInvalid;
  AclMode privs = AclMode::NoRights;
};

using Acl = std::vector<AclItem>;
using AclView = std::span<const AclItem>;

class Object {
 public:
  virtual ~Object();

  ObjectId GetOwnerId() const noexcept { return _owner_id; }
  auto GetAcl() const noexcept { return std::span{_acl}; }
  ObjectType GetType() const noexcept { return _type; }
  std::string_view GetName() const noexcept { return _name; }
  ObjectId GetId() const noexcept { return _id; }

  virtual void WriteInternal(vpack::Builder& build) const = 0;

 protected:
  // 'id' autogenerated IFF 'id' == 0
  Object(ObjectId owner_id, ObjectId id, std::string_view name,
         ObjectType type);

  std::string _name;
  ObjectId _id;
  ObjectId _owner_id;
  ObjectType _type;
  Acl _acl;
};

ObjectId NextId();

struct ObjectByName {
  using is_transparent = void;

  size_t operator()(std::string_view str) const { return absl::HashOf(str); }

  size_t operator()(const std::shared_ptr<Object>& obj) const {
    SDB_ASSERT(obj);
    return (*this)(obj->GetName());
  }

  bool operator()(const std::shared_ptr<Object>& obj,
                  std::string_view str) const {
    return obj->GetName() == str;
  }

  bool operator()(const std::shared_ptr<Object>& r,
                  const std::shared_ptr<Object>& l) const {
    SDB_ASSERT(l);
    SDB_ASSERT(r);
    return l->GetName() == r->GetName();
  }
};

struct ObjectById {
  using is_transparent = void;

  size_t operator()(ObjectId id) const { return absl::HashOf(id); }

  size_t operator()(const auto& obj) const {
    SDB_ASSERT(obj);
    return (*this)(obj->GetId());
  }

  bool operator()(const auto& obj, ObjectId id) const {
    return obj->GetId() == id;
  }

  bool operator()(const auto& r, const auto& l) const {
    SDB_ASSERT(l);
    SDB_ASSERT(r);
    return l->GetId() == r->GetId();
  }
};

class DatabaseObject : public Object {
 public:
  ObjectId GetDatabaseId() const noexcept { return _database_id; }

  virtual void WriteProperties(vpack::Builder& build) const {
    WriteInternal(build);
  }

 protected:
  DatabaseObject(ObjectId owner_id, ObjectId database_id, ObjectId id,
                 std::string_view name, ObjectType type)
    : Object{owner_id, id, name, type}, _database_id{database_id} {}

  const ObjectId _database_id;
};

class SchemaObject : public DatabaseObject {
 public:
  ObjectId GetSchemaId() const noexcept { return _schema_id; }

  // TODO(gnusi): remove it after schema management is done
  void SetSchemaId(ObjectId schema_id) noexcept { _schema_id = schema_id; }

 protected:
  SchemaObject(ObjectId owner_id, ObjectId database_id, ObjectId schema_id,
               ObjectId id, std::string_view name, ObjectType type)
    : DatabaseObject{owner_id, database_id, id, name, type},
      _schema_id{schema_id} {}

 private:
  ObjectId _schema_id;
};

struct ObjectMeta {
  std::string_view name;
  ObjectId id;
  ObjectId owner_id;
  AclView acl;

  static ObjectMeta Make(const Object& obj) noexcept {
    return {
      .name = obj.GetName(),
      .id = obj.GetId(),
      .owner_id = obj.GetOwnerId(),
      .acl = obj.GetAcl(),
    };
  }
};

}  // namespace sdb::catalog
