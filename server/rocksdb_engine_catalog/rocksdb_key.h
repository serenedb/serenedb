////////////////////////////////////////////////////////////////////////////////
/// DISCLAIMER
///
/// Copyright 2014-2023 ArangoDB GmbH, Cologne, Germany
/// Copyright 2004-2014 triAGENS GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is ArangoDB GmbH, Cologne, Germany
////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <rocksdb/slice.h>
#include <vpack/slice.h>

#include <iosfwd>
#include <string>
#include <string_view>

#include "basics/assert.h"
#include "basics/debugging.h"
#include "catalog/identifiers/object_id.h"
#include "catalog/identifiers/revision_id.h"
#include "catalog/types.h"
#include "rocksdb_engine_catalog/rocksdb_types.h"

namespace sdb {

class RocksDBKey {
 public:
  explicit RocksDBKey(std::string* buf) : _buffer{buf} { SDB_ASSERT(_buffer); }

  // verify that a key actually contains the given local document id
  bool containsRevisionId(RevisionId id) const;

  // construct a RocksDB key from another, already filled buffer
  void constructFromBuffer(std::string_view buffer);

  // Create a fully-specified database key
  void constructDatabase(ObjectId database_id);

  void constructSchema(ObjectId database_id, ObjectId schema_id) {
    constructObject(RocksDBEntryType::Schema, database_id, schema_id);
  }

  void constructObject(RocksDBEntryType type, ObjectId database_id,
                       ObjectId id);

  void constructSchemaObject(RocksDBEntryType type, ObjectId database_id,
                             ObjectId schema_id, ObjectId id);

  // Create a fully-specified document key
  void constructDocument(uint64_t object_id, RevisionId doc_id);

  // Create a fully-specified key for an entry in a primary index
  // The indexId is an object ID generated by the engine, rather than the
  // actual index ID.
  void constructPrimaryIndexValue(uint64_t index_id,
                                  std::string_view primary_key);

  // Create a fully-specified key for an entry in an edge index
  // The indexId is an object ID generated by the engine, rather than the
  // actual index ID. The edge index should provide two such object IDs, one
  // for the `_to` sub-index and one for the `_from` sub-index.
  void constructEdgeIndexValue(uint64_t index_id, std::string_view vertex_id,
                               RevisionId doc_id);

  // Create a fully-specified key for an entry in a user-defined,
  // non-unique index (skiplist or permanent)
  // The indexId is an object ID generated by the engine, rather than the
  // actual index ID.
  void constructVPackIndexValue(uint64_t index_id, vpack::Slice index_values,
                                RevisionId doc_id);

  // Create a fully-specified key for an entry in a unique user-defined
  // index
  // The indexId is an object ID generated by the engine, rather than the
  // actual index ID.
  void constructUniqueVPackIndexValue(uint64_t index_id,
                                      vpack::Slice index_values);

  // Create a fully-specified key for a settings value
  void constructSettingsValue(RocksDBSettingsType st);

  // Create a fully-specified key for a counter value
  void constructCounterValue(uint64_t object_id);

  // Create a fully-specified key for a replication applier config
  void constructReplicationApplierConfig(ObjectId database_id);

  // Create a fully-specified key for index estimate values of
  //        a collection
  void constructIndexEstimateValue(uint64_t object_id);

  // Create a fully-specified key for key generator for a collection
  void constructKeyGeneratorValue(uint64_t object_id);

  // Create a fully-specified key for revision tree for a collection
  void constructRevisionTreeValue(uint64_t object_id);

  // Extracts the type from a key
  // May be called on any valid key (in our keyspace)
  static RocksDBEntryType type(const RocksDBKey&);
  static RocksDBEntryType type(rocksdb::Slice slice) {
    return type(slice.data(), slice.size());
  }

  // Extracts the databaseId from a key
  // May be called only on the following key types: Database, Function,
  // Collection, View, Role, other types will throw.
  static Tick databaseId(const rocksdb::Slice& slice) {
    return databaseId(slice.data(), slice.size());
  }

  // Extracts the dataSourceId from a key
  // May be called only on the the following key types: Function, Collection,
  // View, Role, other types will throw.
  static ObjectId dataSourceId(const rocksdb::Slice& slice) {
    return dataSourceId(slice.data(), slice.size());
  }
  static ObjectId SchemaId(const rocksdb::Slice& slice) {
    return SchemaId(slice.data(), slice.size());
  }

  // Extracts the objectId from a key
  //
  // May be called only on the the following key types: Document and
  // all index entries. Other types will behave undefined
  static uint64_t objectId(const rocksdb::Slice& slice) {
    return objectId(slice.data(), slice.size());
  }

  // Extracts the RevisionId from a key
  //
  // May be called only on Document keys. Other types will throw.
  static RevisionId documentId(const rocksdb::Slice&);

  // Extracts the RevisionId from an index key
  //
  // May be called only on Index keys, but not from the edge index
  static RevisionId indexDocumentId(const rocksdb::Slice);
  static RevisionId edgeDocumentId(const rocksdb::Slice);

  // Extracts the primary key (`_key`) from a key
  // May be called only on the following key types: PrimaryIndexValue,
  // EdgeIndexValue, IndexValue. Other types will throw.
  static std::string_view primaryKey(const rocksdb::Slice&);

  // Extracts the vertex ID from a key
  // May be called only on EdgeIndexValue keys. Other types will throw.
  static std::string_view vertexId(const rocksdb::Slice&);

  // Extracts the indexed VPack values from a key
  // May be called only on IndexValue and UniqueIndexValue keys. Other types
  // will throw. Returns only a slice. The value must be copied if one wishes
  // to retain the values after the underlying string goes out of scope.
  static vpack::Slice indexedVPack(const RocksDBKey&);
  static vpack::Slice indexedVPack(const rocksdb::Slice&);

  /// size of internal objectID
  static constexpr size_t objectIdSize() { return sizeof(uint64_t); }

  // Returns a reference to the full, constructed key
  rocksdb::Slice string() const { return rocksdb::Slice(*_buffer); }

  size_t size() const { return _buffer->size(); }

  bool operator==(const RocksDBKey& other) const = default;

  std::string* buffer() const { return _buffer; }

  void reset(rocksdb::Slice slice) {
    SDB_ASSERT(_buffer);
    _type = RocksDBEntryType::Document;
    _buffer->assign(slice.data(), slice.size());
  }

 private:
  // Entry type in the definitions CF
  static RocksDBEntryType type(const char* data, size_t size) {
    SDB_ASSERT(data != nullptr);
    SDB_ASSERT(size >= sizeof(char));

    const auto type = static_cast<RocksDBEntryType>(data[0]);
    switch (type) {
      case RocksDBEntryType::Database:
      case RocksDBEntryType::Function:
      case RocksDBEntryType::Collection:
      case RocksDBEntryType::CounterValue:
      case RocksDBEntryType::SettingsValue:
      case RocksDBEntryType::ReplicationApplierConfig:
      case RocksDBEntryType::IndexEstimateValue:
      case RocksDBEntryType::KeyGeneratorValue:
      case RocksDBEntryType::View:
      case RocksDBEntryType::Role:
      case RocksDBEntryType::TableTombstone:
      case RocksDBEntryType::ScopeTombstone:
        return type;
      default:
        return RocksDBEntryType::Placeholder;
    }
    return type;
  }

  // valid on metadata like database, collection, functions, counters, views,
  // roles...
  static Tick databaseId(const char* data, size_t size);
  static ObjectId dataSourceId(const char* data, size_t size);
  static ObjectId SchemaId(const char* data, size_t size);

  // valid on data entries like document, edge, vpack
  static uint64_t objectId(const char* data, size_t size);
  static RevisionId documentId(RocksDBEntryType, const char*, size_t);
  static std::string_view primaryKey(const char* data, size_t size);
  static std::string_view vertexId(const char* data, size_t size);
  static vpack::Slice indexedVPack(const char* data, size_t size);

 private:
  RocksDBEntryType _type{RocksDBEntryType::Document};
  std::string* _buffer;
};

class RocksDBKeyWithBuffer : public RocksDBKey {
 public:
  RocksDBKeyWithBuffer() : RocksDBKey{&_buffer} {}
  RocksDBKeyWithBuffer(RocksDBKeyWithBuffer&& rhs)
    : RocksDBKey{&_buffer}, _buffer{std::move(rhs._buffer)} {}

  RocksDBKeyWithBuffer operator=(RocksDBKeyWithBuffer&&) = delete;

 private:
  std::string _buffer;
};

}  // namespace sdb
