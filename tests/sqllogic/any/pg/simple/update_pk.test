# Single primary key column - basic update
statement ok
CREATE TABLE single_pk (a INTEGER PRIMARY KEY, b INTEGER);

statement count 3
INSERT INTO single_pk VALUES (1, 10), (2, 20), (3, 30);

query
SELECT * FROM single_pk ORDER BY a;
----
a	b
1	10
2	20
3	30

statement count 1
UPDATE single_pk SET a = 100 WHERE a = 1;

query
SELECT * FROM single_pk ORDER BY a;
----
a	b
2	20
3	30
100	10

statement count 1
UPDATE single_pk SET a = 200, b = 200 WHERE a = 2;

query
SELECT * FROM single_pk ORDER BY a;
----
a	b
3	30
100	10
200	200

onlyif serenedb
query
EXPLAIN(LOGICAL, EXECUTION) UPDATE single_pk SET a = 200, b = 200 WHERE a = 2;
----
QUERY PLAN
LOGICAL PLAN:
- TableWrite UPDATE: -> ROW<rows:BIGINT>
    a := a
    upd$a := upd$a
    b := b
  - Filter: IF(spark_isnotnull(a), true, CAST(pg_error(33575106, 0, null value in column "a" of relation "single_pk" violates not-null constraint, presto_concat(Failing row contains (, COALESCE(CAST(a AS VARCHAR), null), , , COALESCE(CAST(upd$a AS VARCHAR), null), , , COALESCE(CAST(b AS VARCHAR), null), ).)) AS BOOLEAN)) -> ROW<"a":INTEGER,"upd$a":INTEGER,"b":INTEGER>
    - Project: -> ROW<"a":INTEGER,"upd$a":INTEGER,"b":INTEGER>
        a := a
        upd$a := 200
        b := 200
      - Filter: presto_eq(a, 2) -> ROW<"a":INTEGER,"b":INTEGER>
        - TableScan: single_pk -> ROW<"a":INTEGER,"b":INTEGER>
EXECUTION PLAN:
Fragment 0:  numWorkers=0:
-- TableWrite[3][serenedb(table=single_pk, kind=UPDATE)] -> rows:BIGINT
  -- Project[2][expressions: (a:INTEGER, "a"), (upd$a:INTEGER, 200), (b:INTEGER, 200)] -> "a":INTEGER, "upd$a":INTEGER, "b":INTEGER
    -- Filter[1][expression: and(presto_eq("a",2),if(spark_isnotnull("a"),true,cast(pg_error(33575106,0,null value in column "a" of relation "single_pk" violates not-null constraint,presto_concat(Failing row contains (,coalesce(cast("a" as VARCHAR),null),, ,200,, ,200,).)) as BOOLEAN)))] -> "a":INTEGER
      -- TableScan[0][single_pk] -> "a":INTEGER

statement error
UPDATE single_pk SET a = 42, a = 100500 WHERE b = 10;
----
db error: ERROR: multiple assignments to same column "a"


statement error
UPDATE single_pk SET a = 42;
----
db error: ERROR: duplicate key value violates unique constraint "single_pk_pkey"
DETAIL: Key (a)=(42) already exists.


statement ok
DROP TABLE single_pk;

# Multiple primary key columns - update one PK column
statement ok
CREATE TABLE multi_pk (a INTEGER, b INTEGER, c VARCHAR, PRIMARY KEY(a, b));

statement count 3
INSERT INTO multi_pk VALUES (1, 10, 'x'), (1, 20, 'y'), (2, 10, 'z');

query
SELECT * FROM multi_pk ORDER BY a, b;
----
a	b	c
1	10	x
1	20	y
2	10	z

statement count 1
UPDATE multi_pk SET a = 5 WHERE a = 1 AND b = 10;

query
SELECT * FROM multi_pk ORDER BY a, b;
----
a	b	c
1	20	y
2	10	z
5	10	x

statement ok
DROP TABLE multi_pk;

# Multiple primary key columns - update both PK columns
statement ok
CREATE TABLE multi_pk2 (a INTEGER, b INTEGER, c VARCHAR, PRIMARY KEY(a, b));

statement count 2
INSERT INTO multi_pk2 VALUES (1, 10, 'x'), (2, 20, 'y');

query
SELECT * FROM multi_pk2 ORDER BY a, b;
----
a	b	c
1	10	x
2	20	y

statement count 1
UPDATE multi_pk2 SET a = 100, b = 100 WHERE a = 1;

query
SELECT * FROM multi_pk2 ORDER BY a, b;
----
a	b	c
2	20	y
100	100	x

statement ok
DROP TABLE multi_pk2;

# Table with only primary key columns (no other columns)
statement ok
CREATE TABLE only_pk (a INTEGER, b INTEGER, PRIMARY KEY(a, b));

statement count 3
INSERT INTO only_pk VALUES (1, 1), (2, 2), (3, 3);

query
SELECT * FROM only_pk ORDER BY a, b;
----
a	b
1	1
2	2
3	3

statement count 1
UPDATE only_pk SET a = 10 WHERE a = 1;

query
SELECT * FROM only_pk ORDER BY a, b;
----
a	b
2	2
3	3
10	1

statement count 1
UPDATE only_pk SET a = 20, b = 20 WHERE a = 2;

query
SELECT * FROM only_pk ORDER BY a, b;
----
a	b
3	3
10	1
20	20

statement ok
DROP TABLE only_pk;

# Table with PK column 'a' and non-PK column 'upd_a'
# Test the naming collision avoidance with internal column naming
statement ok
CREATE TABLE collision_test (a INTEGER PRIMARY KEY, upd_a INTEGER);

statement count 3
INSERT INTO collision_test VALUES (1, 100), (2, 200), (3, 300);

query
SELECT * FROM collision_test ORDER BY a;
----
a	upd_a
1	100
2	200
3	300

statement count 1
UPDATE collision_test SET a = 10 WHERE a = 1;

query
SELECT * FROM collision_test ORDER BY a;
----
a	upd_a
2	200
3	300
10	100

statement count 1
UPDATE collision_test SET a = 20, upd_a = 2000 WHERE a = 2;

query
SELECT * FROM collision_test ORDER BY a;
----
a	upd_a
3	300
10	100
20	2000

statement ok
DROP TABLE collision_test;

# Update on empty table
statement ok
CREATE TABLE empty_table (a INTEGER PRIMARY KEY, b INTEGER);

statement count 0
UPDATE empty_table SET a = 100 WHERE a = 1;

query
SELECT * FROM empty_table;
----
a	b

statement ok
DROP TABLE empty_table;

# Update primary key to existing value (should fail with duplicate key error)
statement ok
CREATE TABLE dup_test (a INTEGER PRIMARY KEY, b INTEGER);

statement count 2
INSERT INTO dup_test VALUES (1, 10), (2, 20);

statement error
UPDATE dup_test SET a = 2 WHERE a = 1;
----
db error: ERROR: duplicate key value violates unique constraint "dup_test_pkey"
DETAIL: Key (a)=(2) already exists.


query
SELECT * FROM dup_test ORDER BY a;
----
a	b
1	10
2	20

statement ok
DROP TABLE dup_test;

# Update multiple rows with different new PK values
statement ok
CREATE TABLE multi_update (a INTEGER PRIMARY KEY, b INTEGER);

statement count 4
INSERT INTO multi_update VALUES (1, 100), (2, 100), (3, 200), (4, 200);

statement count 2
UPDATE multi_update SET a = a + 10 WHERE b = 100;

query
SELECT * FROM multi_update ORDER BY a;
----
a	b
3	200
4	200
11	100
12	100

statement ok
DROP TABLE multi_update;

# Update with VARCHAR primary key
statement ok
CREATE TABLE varchar_pk (a VARCHAR PRIMARY KEY, b INTEGER);

statement count 3
INSERT INTO varchar_pk VALUES ('key1', 10), ('key2', 20), ('key3', 30);

statement count 1
UPDATE varchar_pk SET a = 'newkey1' WHERE a = 'key1';

query
SELECT * FROM varchar_pk ORDER BY a;
----
a	b
key2	20
key3	30
newkey1	10

statement ok
DROP TABLE varchar_pk;

# Update PK with NULL value
statement ok
CREATE TABLE null_pk_test (a INTEGER PRIMARY KEY, b INTEGER);

statement count 1
INSERT INTO null_pk_test VALUES (1, 10);

# TODO(mkornaukhov) proper error message for not null constraint
statement error
UPDATE null_pk_test SET a = NULL WHERE a = 1;

query
SELECT * FROM null_pk_test ORDER BY a;
----
a	b
1	10

statement ok
DROP TABLE null_pk_test;

# Update with WHERE clause on non-PK column
statement ok
CREATE TABLE where_non_pk (a INTEGER PRIMARY KEY, b INTEGER);

statement count 3
INSERT INTO where_non_pk VALUES (1, 100), (2, 100), (3, 200);

statement count 2
UPDATE where_non_pk SET a = a + 100 WHERE b = 100;

query
SELECT * FROM where_non_pk ORDER BY a;
----
a	b
3	200
101	100
102	100

statement ok
DROP TABLE where_non_pk;

# Update PK with three-column composite key
statement ok
CREATE TABLE triple_pk (a INTEGER, b INTEGER, c INTEGER, d VARCHAR, PRIMARY KEY(a, b, c));

statement count 3
INSERT INTO triple_pk VALUES (1, 1, 1, 'x'), (1, 1, 2, 'y'), (2, 2, 2, 'z');

statement count 1
UPDATE triple_pk SET a = 10, b = 10 WHERE a = 1 AND b = 1 AND c = 1;

query
SELECT * FROM triple_pk ORDER BY a, b, c;
----
a	b	c	d
1	1	2	y
2	2	2	z
10	10	1	x

statement count 1
UPDATE triple_pk SET c = 20 WHERE a = 1 AND b = 1 AND c = 2;

query
SELECT * FROM triple_pk ORDER BY a, b, c;
----
a	b	c	d
1	1	20	y
2	2	2	z
10	10	1	x

statement ok
DROP TABLE triple_pk;

# Update same row multiple times in sequence
statement ok
CREATE TABLE sequential_update (a INTEGER PRIMARY KEY, b INTEGER);

statement count 1
INSERT INTO sequential_update VALUES (1, 10);

statement count 1
UPDATE sequential_update SET a = 2 WHERE a = 1;

statement count 1
UPDATE sequential_update SET a = 3 WHERE a = 2;

statement count 1
UPDATE sequential_update SET a = 4 WHERE a = 3;

query
SELECT * FROM sequential_update ORDER BY a;
----
a	b
4	10

statement ok
DROP TABLE sequential_update;

# Large batch update (more than 1024 rows)
statement ok
CREATE TABLE large_update (a INTEGER PRIMARY KEY, b INTEGER);

statement count 2000
INSERT INTO large_update SELECT x, x * 10 FROM generate_series(1, 2000) AS t1(x);

query
SELECT COUNT(*) FROM large_update;
----
count
2000

statement count 100
UPDATE large_update SET a = a + 10000 WHERE a <= 100;

query
SELECT COUNT(*) FROM large_update WHERE a > 10000;
----
count
100

query
SELECT MIN(a), MAX(a) FROM large_update;
----
min	max
101	10100

statement ok
DROP TABLE large_update;

# Update with TIMESTAMP primary key
statement ok
CREATE TABLE timestamp_pk (a TIMESTAMP PRIMARY KEY, b INTEGER);

statement count 2
INSERT INTO timestamp_pk VALUES ('2025-01-01 10:00:00', 1), ('2025-01-02 10:00:00', 2);

statement count 1
UPDATE timestamp_pk SET a = '2025-01-10 10:00:00' WHERE a = '2025-01-01 10:00:00';

query
SELECT * FROM timestamp_pk ORDER BY a;
----
a	b
2025-01-02 10:00:00	2
2025-01-10 10:00:00	1

statement ok
DROP TABLE timestamp_pk;

# Update all rows
statement ok
CREATE TABLE update_all (a INTEGER PRIMARY KEY, b INTEGER);

statement count 3
INSERT INTO update_all VALUES (1, 10), (2, 20), (3, 30);

statement count 3
UPDATE update_all SET a = a + 100;

query
SELECT * FROM update_all ORDER BY a;
----
a	b
101	10
102	20
103	30

statement ok
DROP TABLE update_all;

statement ok
CREATE TABLE multi_pk2 (a INTEGER, b INTEGER, c VARCHAR, PRIMARY KEY(a, b));

statement ok
INSERT INTO multi_pk2 VALUES (1,1, 'a'), (1,2, 'b');

statement error
UPDATE multi_pk2 SET a = 1, b = 2 WHERE a = 1 AND b = 1;
----
db error: ERROR: duplicate key value violates unique constraint "multi_pk2_pkey"
DETAIL: Key (a, b)=(1, 2) already exists.


# Shows that lookup in transaction write buffer is required, non-reentrant lock is not a solution

statement ok
BEGIN;

statement count 1
UPDATE multi_pk2 SET a = 3, b = 3 WHERE a = 1 AND b = 1;

# PK (1, 1) is already locked in previous statement
statement count 1
INSERT INTO multi_pk2 VALUES (1,1, 'c')

statement ok
COMMIT;

query
SELECT * FROM multi_pk2 ORDER BY a;
----
a	b	c
1	1	c
1	2	b
3	3	a
