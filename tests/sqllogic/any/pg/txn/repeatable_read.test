# Test: Repeatable Read isolation level
# Verifies:
#   1. Syntax for repeatable read isolation level
#   2. Read your own writes
#   3. No dirty reads
#   4. No nonrepeatable reads
#   5. No phantom reads
#   6. Read-your-own-writes edge cases
#   7. Snapshot stability with aggregates
#   8. Rollback visibility
#   9. Autocommit vs snapshot
#  10. Empty table / boundary cases
#  11. Snapshot timing (snapshot at first data-access, not at BEGIN)
#
# TODO(mkornaukhov): Add DDL interaction tests
#   - conn1 in repeatable read txn, conn2 does ALTER TABLE ADD COLUMN
#   - conn1 in repeatable read txn, conn2 does DROP TABLE

statement ok
CREATE TABLE t(key INT PRIMARY KEY, value INT);

statement ok
INSERT INTO t VALUES (1, 10), (2, 20), (3, 30);


###############################################################################
# 1. Syntax for repeatable read isolation level
###############################################################################

statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
COMMIT;


statement ok
BEGIN ISOLATION LEVEL REPEATABLE READ;

statement ok
COMMIT;


statement ok
START TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
COMMIT;


statement ok
BEGIN;

statement ok
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
COMMIT;


statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL REPEATABLE READ;


###############################################################################
# 2. Read your own writes
###############################################################################

statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
INSERT INTO t VALUES (4, 40);

statement ok
UPDATE t SET value = 99 WHERE key = 1;

query
SELECT * FROM t ORDER BY key;
----
key	value
1	99
2	20
3	30
4	40

statement ok
ROLLBACK;


###############################################################################
# 3. No dirty reads
#    conn2 must NOT see uncommitted writes from conn1
###############################################################################

statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
INSERT INTO t VALUES (5, 50);

statement ok
UPDATE t SET value = 999 WHERE key = 1;

# conn2 starts its own transaction and reads — must see only committed data
connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

connection conn2
query
SELECT * FROM t ORDER BY key;
----
key	value
1	10
2	20
3	30

connection conn2
statement ok
COMMIT;

# conn1 rolls back its dirty writes
statement ok
ROLLBACK;


###############################################################################
# 4. No nonrepeatable reads
#    conn2 reads a row, conn1 updates and commits it,
#    conn2 reads the same row again — must see the original value
###############################################################################

connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

# First read by conn2
connection conn2
query
SELECT value FROM t WHERE key = 1;
----
value
10

# conn1 updates and commits
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
UPDATE t SET value = 999 WHERE key = 1;

statement ok
COMMIT;

# Second read by conn2 — must still see the original value
connection conn2
query
SELECT value FROM t WHERE key = 1;
----
value
10

connection conn2
statement ok
COMMIT;

# Verify the update is visible outside both transactions
query
SELECT value FROM t WHERE key = 1;
----
value
999

# Restore original value
statement ok
UPDATE t SET value = 10 WHERE key = 1;


###############################################################################
# 5. No phantom reads
#    conn2 runs a range query, conn1 inserts a new row and commits,
#    conn2 runs the same range query — must NOT see the new row
###############################################################################

connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

# First range query by conn2
connection conn2
query
SELECT * FROM t WHERE key >= 1 AND key <= 10 ORDER BY key;
----
key	value
1	10
2	20
3	30

# conn1 inserts a new row that would match the range and commits
statement ok
INSERT INTO t VALUES (5, 50);

# Second range query by conn2 — must return the same set of rows
connection conn2
query
SELECT * FROM t WHERE key >= 1 AND key <= 10 ORDER BY key;
----
key	value
1	10
2	20
3	30

connection conn2
statement ok
COMMIT;

# Outside both transactions, the inserted row is visible
query
SELECT * FROM t WHERE key >= 1 AND key <= 10 ORDER BY key;
----
key	value
1	10
2	20
3	30
5	50


###############################################################################
# 6. Read-your-own-writes edge cases
###############################################################################

# 7a. Multiple updates to the same row — final read sees last update
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
UPDATE t SET value = 100 WHERE key = 1;

statement ok
UPDATE t SET value = 200 WHERE key = 1;

statement ok
UPDATE t SET value = 300 WHERE key = 1;

query
SELECT value FROM t WHERE key = 1;
----
value
300

statement ok
ROLLBACK;

# 7b. DELETE then SELECT — row should be gone
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
DELETE FROM t WHERE key = 2;

query
SELECT * FROM t WHERE key = 2;
----
key	value

statement ok
ROLLBACK;

# 7c. INSERT, UPDATE the inserted row, then SELECT
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
INSERT INTO t VALUES (100, 1);

statement ok
UPDATE t SET value = 2 WHERE key = 100;

query
SELECT * FROM t WHERE key = 100;
----
key	value
100	2

statement ok
ROLLBACK;

# 7d. INSERT, DELETE the inserted row, then SELECT — row should be gone
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
INSERT INTO t VALUES (100, 1);

statement ok
DELETE FROM t WHERE key = 100;

query
SELECT * FROM t WHERE key = 100;
----
key	value

statement ok
ROLLBACK;


###############################################################################
# 7. Snapshot stability with aggregates
#    Aggregates must return consistent results even after concurrent commits
###############################################################################

query
SELECT * FROM t ORDER BY key;
----
key	value
1	10
2	20
3	30
5	50

connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

# First aggregate reads by conn2
connection conn2
query
SELECT COUNT(*) AS cnt FROM t;
----
cnt
4

connection conn2
query
SELECT SUM(value) AS total FROM t;
----
total
110

# conn1 inserts rows and commits
statement ok
INSERT INTO t VALUES (6, 60), (7, 70);

# Aggregates by conn2 must remain stable
connection conn2
query
SELECT COUNT(*) AS cnt FROM t;
----
cnt
4

connection conn2
query
SELECT SUM(value) AS total FROM t;
----
total
110

connection conn2
statement ok
COMMIT;

# Outside the transaction, new rows are visible
query
SELECT COUNT(*) AS cnt FROM t;
----
cnt
6


###############################################################################
# 8. Rollback visibility
#    conn1 updates and rolls back, conn2 must never see the intermediate state
###############################################################################

connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

# conn2 reads original value
connection conn2
query
SELECT value FROM t WHERE key = 1;
----
value
10

# conn1 updates in a transaction then rolls back
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

statement ok
UPDATE t SET value = 777 WHERE key = 1;

statement ok
ROLLBACK;

# conn2 reads again — must still see the original value (not 777)
connection conn2
query
SELECT value FROM t WHERE key = 1;
----
value
10

connection conn2
statement ok
COMMIT;

# Outside all transactions, value is still original (rollback had no effect)
query
SELECT value FROM t WHERE key = 1;
----
value
10


###############################################################################
# 9. Autocommit vs snapshot
#     Multiple autocommit writes by conn1 between two reads by conn2
###############################################################################

connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

connection conn2
query
SELECT * FROM t ORDER BY key;
----
key	value
1	10
2	20
3	30
5	50
6	60
7	70

# conn1 does multiple autocommit writes
statement ok
INSERT INTO t VALUES (8, 80);

statement ok
UPDATE t SET value = 999 WHERE key = 1;

statement ok
DELETE FROM t WHERE key = 2;

# conn2 re-reads — must see its original snapshot
connection conn2
query
SELECT * FROM t ORDER BY key;
----
key	value
1	10
2	20
3	30
5	50
6	60
7	70

connection conn2
statement ok
COMMIT;

# Restore: undo conn1 autocommit changes for subsequent tests
statement ok
UPDATE t SET value = 10 WHERE key = 1;

statement ok
INSERT INTO t VALUES (2, 20);

# Clean up key 8 which was inserted above
statement ok
DELETE FROM t WHERE key = 8;


###############################################################################
# 10. Empty table / boundary cases
###############################################################################

statement ok
CREATE TABLE t_empty(id INT PRIMARY KEY, val INT);

# conn2 starts txn on empty table
connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

connection conn2
query
SELECT * FROM t_empty;
----
id	val

# conn1 inserts into the empty table and commits
statement ok
INSERT INTO t_empty VALUES (1, 100);

# conn2 still sees empty table
connection conn2
query
SELECT * FROM t_empty;
----
id	val

connection conn2
statement ok
COMMIT;

# Outside the transaction, the row is visible
query
SELECT * FROM t_empty;
----
id	val
1	100


###############################################################################
# 11. Snapshot timing: snapshot is taken at first data-access statement,
#     not at BEGIN (matches PostgreSQL behavior)
###############################################################################

# conn2 BEGINs, conn1 inserts+commits BEFORE conn2's first read.
# Since conn2 hasn't accessed data yet, the snapshot is not yet taken,
# so conn2 WILL see the insert.
connection conn2
statement ok
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

# conn1 inserts and commits AFTER conn2's BEGIN but BEFORE conn2's first read
statement ok
INSERT INTO t_empty VALUES (2, 200);

# conn2's first read — SEES key=2 because snapshot is taken NOW
connection conn2
query
SELECT * FROM t_empty ORDER BY id;
----
id	val
1	100
2	200

# Now conn1 inserts another row and commits
statement ok
INSERT INTO t_empty VALUES (3, 300);

# conn2's second read — must NOT see key=3, snapshot was pinned at first read
connection conn2
query
SELECT * FROM t_empty ORDER BY id;
----
id	val
1	100
2	200

connection conn2
statement ok
COMMIT;

# Outside the transaction, all rows are visible
query
SELECT * FROM t_empty ORDER BY id;
----
id	val
1	100
2	200
3	300
